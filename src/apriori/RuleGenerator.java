package apriori;

import java.util.*;
import rules.*;

public class RuleGenerator
{
	public ArrayList<Rule> rulelist;
        public int n_examples;
	
	public RuleGenerator()
	{
		rulelist = new ArrayList<Rule>();
	}
	
    public RuleGenerator(ArrayList<ArrayList<ItemSet>> aprioriset, float minacc, int n_examples)
	{
                this.n_examples = n_examples;
		rulelist = makeAllRules(aprioriset, minacc);
	}
	
	public ArrayList<Rule> makeAllRules(ArrayList<ArrayList<ItemSet>> aprioriset, float minacc)
	{
		ArrayList<ItemSet> supersets;
		ArrayList<Rule> newrules = new ArrayList<Rule>();
		Rule temprule;
		float checkval;
		for (int i = 0; i < (aprioriset.size() - 1); i++)
		{
			for (int j = 0; j < aprioriset.get(i).size(); j++)
			{
				supersets = findSuperSets(aprioriset.get(i).get(j), aprioriset);
				for (int k = 0; k < supersets.size(); k++) //may god forgive me for making a triple-nested for loop
				{
					checkval = (float) supersets.get(k).support / (float) aprioriset.get(i).get(j).support;
					if (checkval >= minacc)
					{
                                                temprule = makeRule(aprioriset.get(i).get(j), supersets.get(k), aprioriset);
						newrules.add(temprule);
					}
				}
			}
		}
		return newrules;
	}
	
        public Rule makeRule(ItemSet sub, ItemSet obj, ArrayList<ArrayList<ItemSet>> aprioriset)
	{
		//assuming sub is a subset of obj
		Rule newrule = new Rule();
		newrule.cond = sub.items;
		newrule.conc = splitSet(sub, obj);
                ItemSet concSet = findItemSet(newrule.conc, aprioriset);
		newrule.freq = (float) obj.support / (float) sub.support;
                newrule.lift = newrule.freq / ((float) concSet.support / (float) n_examples);
		return newrule;
	}
	
	public ArrayList<Predicate> splitSet(ItemSet sub, ItemSet obj)
	{
		//with this function we want to return the predicates in obj that AREN'T in sub
		//we assume that sub is a subset of obj
		//if the item sets in sub and obj weren't originally sorted, i think they'd get sorted by the isSubset() function before calling this
		int i = 0;
		int j = 0;
		int comp;
		ArrayList<Predicate> disjoint = new ArrayList<Predicate>();
		while (i < sub.items.size() && j < obj.items.size())
		{
			comp = sub.items.get(i).compareTo(obj.items.get(j));
			if (comp > 0)
			{
				disjoint.add(obj.items.get(j));
				j++;
			}
			if (comp == 0)
			{
				i++;
				j++;
			}
			if (comp < 0) //i don't think this would ever happen if the function is called properly..
			{
				System.out.println("in splitSet() sub is not a subset of obj");
				return null;
			}
		}
		while (j < obj.items.size())
		{
			disjoint.add(obj.items.get(j));
			j++;
		}
		return disjoint;
	}

    // Given a list of predicates, find the item set corresponding to it
    public ItemSet findItemSet(ArrayList<Predicate> preds, ArrayList<ArrayList<ItemSet>> aprioriset) {
        ArrayList<Predicate> preds1 = new ArrayList<Predicate>(preds);
        Collections.sort(preds1);
        for (ItemSet i : aprioriset.get(preds.size() - 1)) {
            ArrayList<Predicate> preds2 = new ArrayList<Predicate>(i.items);
            Collections.sort(preds2);
            if (preds1.equals(preds2))
                return i;
            if (preds1.containsAll(preds2) && preds2.containsAll(preds1))
                System.out.println("Shouldn't happend");
        }
        System.out.println(preds.size());
        for (Predicate p : preds1)
            System.out.println(p.display());
        for (Predicate p : preds)
            System.out.println(p.display());
        throw new RuntimeException("Item set not found! This should never happen.");
    }
	
	public ArrayList<ItemSet> findSuperSets(ItemSet sub, ArrayList<ArrayList<ItemSet>> obj)
	{
		ArrayList<ItemSet> supersets = new ArrayList<ItemSet>();
		for (int i = sub.items.size(); i < obj.size(); i++) //in the list of lists of itemsets generated by apriori, the number of items in a set is equal to the list's index plus one
		{ //so if we initialize i to the size of the item sets in sub, then every itemset in obj.get(i) will be larger than sub
			for (int j = 0; j < obj.get(i).size(); j++)
			{
				if (isSubset(sub, obj.get(i).get(j)))
				{
					supersets.add(obj.get(i).get(j)); //we could probably break early if we don't find any supersets for some value of i (in that case there wouldn't be any supersets in i + 1 either) 
				} //but whatever..
			}
		}
		return supersets;
	}
	
	public boolean isSubset(ItemSet sub, ItemSet obj)
	{
		//this function returns true if the item set in sub is a subset of the itemset in obj
		//take care that when calling this that sub has a smaller item set than obj
		Collections.sort(sub.items);
		Collections.sort(obj.items); //these sorts might be superfluous, i forget if the item lists are sorted after apriori or not
		int i = 0;
		int j = 0;
		int comp;
		while (i < sub.items.size() && j < obj.items.size())
		{
			comp = sub.items.get(i).compareTo(obj.items.get(j));
			if (comp > 0) //the current item in the obj list is "smaller" than the item in the sub list. acceptable.
			{
				j++;
			}
			if (comp == 0) //an element in the sub list is in the obj list. this is what we're looking for!
			{
				i++;
				j++;
			}
			if (comp < 0) //this will only be true if the element in sub is not in obj
			{
				return false; //therefore, sub is not a subset of obj
			}
		}
		return (i >= sub.items.size()); //if we iterated through every element in sub, then every element of sub is in obj
	}
}
